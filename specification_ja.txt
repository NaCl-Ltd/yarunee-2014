= Summary of the Task

我々が見つけたエンジニアのノートによれば、彼らはプロジェクト中止前に動作するハードウェアとソフトウェアをなんとか手に入れたようだ。
不幸にもオリジナルのソフトウェアを復元できなかったが、我々はハードウェアの詳細な設計ノートを持っている。

今のところアーケード用ハードウェアのシミュレーションソフトを持っている。
あなたたちにやってほしいのは、アーケード用ハードウェアで動作するソフトウェアを書くことだ。

= Lightning Round Summary

lightning roundでは、ゴーストと対決する一人用のLambda-Manのいる"classic"バージョンをプレイする。

あなたたちに挑戦してほしいのはLambda-ManのAIを書くことだ。
それは審判から提供されるゴーストAIと、審判から提供される迷路内で対決する。

あなたたちはいくつかの迷路とゴーストAIのわずかな(賢くはない)アセンブリコードが提供される。

lightning roundは最初の24時間に開催される。12:00 UTC 26/07/2014までに提出すること。

= Full Round Summary

full roundはだいたいlightning roundと同じだが、ちょっと異なる。
詳細はlightning roundが終わったら公開される。
lightning roundが終わったらフロントページをチェックすること。

full roundは72時間いっぱい開催される。12:00 UTC 28/07/2014までに提出すること。

= The Lambda-Man game rules

== 目標

Lambda-Manは壁からなる2次元の迷路上にいて、追いかけてくるゴーストを避けながらできる限りのpillを食べなければならない。
Lambda-Manは3つのライフを持っていて、ゴーストがLambda-Manに追いつくとライフを失う。
ライフをすべて失うとゲームオーバー。
すべてのpillを食べるとLambda-Manはレベルクリアとなる。

pillに加えてLambda-Manはpower pillも食べる。
power pillを食べるとLambda-Manは短時間の間、ゴーストを食べられるようになる。

開始から特定の時間が経つと特定の場所に現れるフルーツを消える前に食べるとボーナス点が加算される。

次のシンボルが様々な要素を表現する。

<space>: なにもない
#: 壁
.: Pill
o: Power Pill
%: フルーツ
\: Lambda-Man	
=: ゴースト

= メカニクス

この世界は完全に決定的で、ターン制になっている。
それぞれのターンでは次のようになる。
1. すべてのLambda-Manとゴーストがスケジュールされたように動く。
   (Lambda-Manとゴーストはすべてのターンで動くわけではない)
2. いくつかのアクションがある
   (fright mode deactivating, フルーツの出現/消失)
3. Lambda-Manがpill/power pill/フルーツと同じマスにいるかチェックされる。
　1. pillのマスにいる場合、pillはLambda-Manに食べられて消える
  2. power pillのマスにいる場合、power pillはLambda-Manに食べられて消え、ゴーストを食べられるfright modeが直ちに始まる。
  3. フルーツのマスにいる場合、フルーツはLambda-Manに食べられて消える。

4. 1つ以上のゴーストがLambda-Manと同じマスにいる場合、fright modeならゴーストを食べ、fright modeでないならライフを失う。
5. すべてのpill(power pillは含まない)が食べられたらLambda-Manの勝ちでゲーム終了
6. ライフが0になったらLambda-Manの負けでゲーム終了
7. ターンカウンタがインクリメントされる

= Losing a life

fright modeではないターンの最後にLambda-Manとゴーストが同じマスにいるとライフを失う。
この場合、Lambda-Manとゴーストは直ちにスタート位置に戻り、その時の方向を向く。
(なので、次のターンの最初ではLambda-Manとゴーストは自身のスタート位置にいる)

= Power Pills

Power Pillを食べると、すべてのゴーストは前にいた方向に向きを変える。
fright modeの間、ゴーストがLambda-Manと同じマスにいるとLambda-Manに食べられる。
ゴーストは食べられると、スタート位置に戻り、スタート時の方向を向き、fright modeが終わるまで見えない。
見えない間はゴーストはLambda-Manを食べたり食べられたりできない。

fright mode中にpower pillを食べるとfright modeのターンカウントがリセットされる。

fright modeが終わるとすべてのゴーストはまた見えるようになる。

= Scoring

ゲームの目的は高いスコア(すべてのレベルで獲得したスコアの合計)を獲得することです。
スコアは次のように決まります。

pillを食べるごとに10ポイント
power pillを食べるごとに50ポイント
フルーツはそのフレーバーごとにポイントが変わります。
フルーツのフレーバーは次のようにレベルによって決定されます。

レベル　フレーバー　 ポイント
1       チェリー     100
2       ストロベリー 300
3       ピーチ       500
4       ピーチ       500
5       アップル     700
6       アップル     700
7       グレープ     1000
8       グレープ     1000
9       ギャラクシアン 2000
10      ギャラクシアン 2000
11      ベル         3000
12      ベル         3000
> 12    キー         5000

マップのレベルはそのエリアによって決まります。
与えられたマップのサイズ(mapWidth*mapHeight)によってレベルが次を満たすように決まります。

100 * (level - 1) < mapWidth * mapHeight <= 100 * level

例えば、マップサイズが15*18=270だとレベル3のマップです(200<270<=300)。

fright modeの間、ゴーストを食べると最初は200ポイントです。
別のpower pillを食べずに連続してゴーストを食べると1600を上限にポイントが2倍になっていきます。

Lambda-Manがすべてのpillを食べるとボーナスをもらえます。
ボーナスとしてスコアが(残りのライフ数+1)倍されます。
例えば、ライフが残り1だった場合、スコアが2倍されます。

== Ticks

Lambda-Manの世界はターン制です。
Ultimate Tick Clock(UTC)は現在のtick timeを与え、各ゲームの始まりでは1から数え始めます。
ゲームはEnd Of Livesという特定のUTCに達するまで(このときライフは0になります)続きます。

End Of Lives: 127 * mapWidth * mapHeight * 16

各レベルで二つのフルーツが特定のUTCで現れます。
二つ目のフルーツは一つ目が食べられる/食べられないに関わらず現れます。

フルーツ1の出現: 127 * 200(UTC)
フルーツ2の出現: 127 * 400(UTC)

それぞれのフルーツは食べられるか特定のUTCになるまで出現しています。

フルーツ1の消失: 127 * 280(UTC)
フルーツ2の消失: 127 * 480(UTC)

power pillをfright modeになります。
fright modeはpower pillを食べてから決められた期間だけ続きます。

fright modeの期間: 127 * 20

Lambda-Manとゴーストは異なる速さで移動します。
Lambda-Manは何かを食べるときはゆっくり移動し、ゴーストはfright modeの間はゆっくり移動します。
すべての移動は規則的で、移動に必要なターンは次のようになります。
例えば、Lambda-Manは最初127ターン目で動き、次は254ターン目です。

イベント        移動に必要なターン
Lambda-Man 	127
Lambda-Man (eating) 	137
Ghost AI 1 	130
Ghost AI 2 	132
Ghost AI 3 	134
Ghost AI 4 	136
Ghost AI 1 (fright) 	195
Ghost AI 2 (fright) 	198
Ghost AI 3 (fright) 	201
Ghost AI 4 (fright) 	204

== 移動

Lambda-Manは壁でない隣接したマスへ移動できます。
隣接したマスとは上、下、左、右のマスです。

Lambda-Manが不正な動きを選択した場合、動きが止まります。

ゴーストは壁でない隣接したマスへ移動します。
ゴーストは、四方が壁に囲まれてない限り動かなければなりません。
さらに、ゴーストは(その方向しかない限り)現在の方向と反対方向へは動けません。

その結果、ゴーストは合流点でしか向きを選ぶことしかできず、引き返すことはできません。
合流点とは少なくとも3方向の隣接したマスが壁ではないマスです。
例えば、次はすべて合流点です。

 # #     # #             # #     # # 
## ##    # ##   #####   ## #    ## ##
  =      #=       =       =#      =  
#####    # ##   ## ##   ## #    ## ##
         # #     # #     # #     # # 

ゴーストがカーブに着くと、カーブに沿って動きます。
ゴーストが行き止まりに着くと、引き返します。

ゴーストが合流点で不正な動きを選ぶと、可能なら前と同じ方向に動きつづけ、可能でないなら上、右、下、左の順で最初に移動可能な方向に行きます。

ゲームの始まりでは、すべてのLambda-Manとゴーストは下を向いています。

= Tournament scoring

lightning roundではあなたのLambda-Manと審判から提供されたゴーストが審判から提供されたマップで戦います。

あなたのlightning roundでのすべてのスコアは、一連のゲームでのスコアの合計点です。
実際に使われたマップやゴーストは明かされませんが、easyからhardまで変動します。
マッププロパティは後述します。

= Map properties

マップは長方形です。
マップのx,y座標は0から数えます。
左上の角が(0,0)で、x軸が右方向に伸びて、y座標が下方向に伸びます。

マップは迷路のようです。
マップは1マス分の廊下で構成されています。
形式的に表現すると、2x2の壁のないエリアは存在しません。

マップは端は壁で囲まれています。

すべてのpillは到達可能なマップ上に現れます。

マップごとにサイズやゴーストの数、power pillの数が変わります。
簡単なマップは小さくてゴーストも少なくpower pillもたくさん現れます。
難しいマップは大きく、たくさんゴーストがいてpower pillもなかなか現れません。
マップの最大サイズは256*256です。

= Lambda-Man CPU

我々はプロセッサのISA（バスアーキテクチャ）とアセンブリコードのいくつかのビットを含むLambda-Man AIチームによるプログラミング環境に関するいくつかのドキュメントを修復することができました。
我々もまたLambda-Man AIチームとLISP狂信者とLISPのフォームを知っている。しかし残念なことにLISPコードもそのコンパイラも見つけることができませんでした。

LamCoの"General Compute Coprocessor" (GCC)はどちらかといえば型にはまらなく-for its time-洗練されたCoprocessorです。
それはLISPコンパイラのために設計されたように見えます。
直交する命令セットというよりは、（我々が思うに）コンパイラにとって有用な、やや特別な命令の正しい数値を持っています。

We did however find a handwritten note by one of the engineers indicating that someone had written a compiler from a variant of Pascal, albeit with some limitations.

Fortunately we do have the original documentation of the processor which describes the instructions and operation in detail, though sadly not very much on how it was intended to be used by a compiler.

この節より下に我々のコメントに沿ってオリジナルドキュメントからの抜粋を含んでいます。

== General Architecture

マシンはスタックベースで、3つのスタックが異なる目的で使われます。
比較的大きなメモリを使用します。
メモリアクセスする方法はあまり普通ではありません。
メモリの中の生きているスタックとは別に、残りのメモリはガベージコレクトされたヒープとして使用され、GCはハードウェアによって実行されます。
このため、汎用的なメモリアクセス方法はありません。
メモリアクセスはスタックの中かGCされたヒープの中に限られます。

== CPU Registers

プログラマに見えるレジスタは4つあり、それらは特別な目的を持っています。

%c: コントロールレジスタ(プログラムカウンタ / インストラクションポインタ)
%s: データスタックレジスタ
%d: コントロールスタックレジスタ
%e: 環境フレームレジスタ

== Memory stacks

3つのレジスタがメモリ上の特別なデータ構造を指します。

* データスタック
* コントロールスタック
* 環境フレームチェイン

メモリの残りはデータヒープのためにとってあります。

== Control register and program code layout

データとコードのために、マシンは論理的に分けられたアドレス空間をもっています。
%cレジスタはインストラクションポインタで、次に実行されるべき命令を指しています。
プログラムは小さいアドレスから大きいアドレスに向かって並べられます。
インストラクションポインタ上のほとんどの命令の効果は、単にその値をインクリメントすることです。

== Data stack and register

データスタックは、計算の間の中間データを保存したり、関数呼び出しの値をreturnするのに使われます。
それは論理的に連続したスタックです。
%sレジスタはスタックのトップを指しています。
多くの命令はデータを単にスタックにpopしたりpushしたりするだけです。
例えば、ADD命令は2つの整数値をpopして合計をpushします。

== Control stack and register

コントロールスタックは関数呼び出しのreturn情報を保存するのに使われます。
リターンアドレスと環境フレームポインタです。
それは論理的に連続したスタックです。
複雑な制御フローの命令のみがコントロールスタックとレジスタに影響を与えます。詳細はSEL/JOINやAP/RAP/RTNを見てください。

== Environment frames and register

環境は関数のパラメータを含むローカル変数の格納に使われます。
データスタックの上に環境から値を読むための命令があります。
環境は、ローカル変数付きのローカルブロックや関数のような高級言語におけるネストされた変数スコープで使われるフレームのチェインから成ります。

環境は2つのスタック構造よりも複雑です。
contiguous stackというよりは、環境フレームのチェインから成ります。
各フレームはその親フレームへのポインタを含んでいます。
事実、フレームのチェインはスタックほど厳しくありません: フレームの生存期間は単純なLIFFOスタックの順番とは違います。
フレームはハードウェアGCによって管理されているためです。

各フレームは親フレームとゼロか多くのデータ値のポインタからなります。
%eレジスタはローカルフレームを差します。
一般に環境フレームのチェインの一連の要求として、マシンはローカルフレームまたはその親フレームのいずれかから値を読むための機能を持っています。

(We believe in the real hardware this feature was implemented in microcode, with internal registers to cache the outermost frame and a fixed number of the inner most frames for quick access).

== Data heap and data values

== Examples

== The processor/co-processor interface

== Lambda-Man AI interface

== Example

== Resource constraints

== Errors
