(define nil 0)
(define true 1)
(define false 0)

; (fold + 0 (list 1 2 3))みたいにクロージャとして使いたい時のために
; 組込命令を関数としても定義しておく。
(define (+ x y) (+ x y))
(define (- x y) (- x y))
(define (* x y) (* x y))
(define (/ x y) (/ x y))
(define (= x y) (= x y))
(define (> x y) (> x y))
(define (>= x y) (>= x y))
(define (< x y) (< x y))
(define (<= x y) (<= x y))
(define (cons x y) (cons x y))
(define (car x) (car x))
(define (cdr x) (cdr x))

(define (not x)
  (if x false true))

(define (null? x)
  (and (int? x) (= x 0)))

; 左からの畳込み
(define (fold kons knil clist)
  (if (null? clist)
    knil
    (fold kons (kons knil (car clist)) (cdr clist))))

; 右からの畳込み
(define (fold-right kons knil clist)
  (if (null? clist)
    knil
    (kons (car clist) (fold-right kons knil (cdr clist)))))

; 写像
; (map (lambda (x) (* x x)) (list 1 2 3))
; => (1, 4, 9)
(define (map proc clist)
  (fold-right (lambda (x l) (cons (proc x) l)) nil clist))

; リスト内にpredが真になる要素があるとき真を返す
(define (any? pred ls)
  (fold (lambda (b item) (or b (pred item))) false ls))

; リスト内の全ての要素に対してpredが真になるとき真を返す
(define (all? pred ls)
  (fold (lambda (b item) (and b (pred item))) true ls))

; リスト内にpredが真になる要素がないとき真を返す
(define (none? pred ls)
  (fold (lambda (b item) (and b (not (pred item)))) true ls))

; n番目(0始まり)の要素
; (list-ref (list 5 6 7 8 9) 2) => 7
(define (list-ref clist n)
  (if (or (null? clist) (< n 0))
    nil
    (if (= n 0)
      (car clist)
      (list-ref (cdr clist) (- n 1)))))

; vim: set filetype=lisp :
